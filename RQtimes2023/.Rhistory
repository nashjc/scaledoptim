points(xx,yy, type='l')
fti<-coef(ftime)
ww<-fti[1]+fti[2]*xx+fti[3]*xx*xx
points(n, tf, col='red')
points(xx, ww, type='l', col='red')
title(main="Execution time vs matrix size")
title(sub="molermat (black) and molerfast (red) matrix builds")
osize<-lm(os~n+n2)
summary(osize)
cos<-coef(osize)
zz<-cos[1]+cos[2]*xx+cos[3]*xx*xx
plot(n, os)
points(xx, zz, type='l')
title(main="Execution time vs matrix size")
title(sub="eigen() on Moler matrix")
rqdir<-function(x, AA){
rq<-0.0
n<-length(x) # assume x, AA conformable
for (i in 1:n) {
for (j in 1:n) {
rq<-rq+x[i]*AA[[i,j]]*x[j]
}
}
rq
}
ray1<-function(x, AA){
rq<-  t(x)%*%AA%*%x
}
ray2<-function(x, AA){
rq<-  as.numeric(crossprod(x, crossprod(AA,x)))
}
ray3<-function(x, AA, ax=axftn){
# ax is a function to form AA%*%x
rq<- - as.numeric(crossprod(x, ax(x, AA)))
}
ax<-function(x, AA){
u<- as.numeric(AA%*%x)
}
axx<-function(x, AA){
u<- as.numeric(crossprod(AA, x))
}
aximp<-function(x, AA=1){ # implicit moler A*x
n<-length(x)
y<-rep(0,n)
for (i in 1:n){
tt<-0.
for (j in 1:n) {
if (i == j) tt<-tt+i*x[i]
else tt<-tt+(min(i,j) - 2)*x[j]
}
y[i]<-tt
}
y
}
ident<-function(x, B=1) x # identity
axmolerfast <- function(x, AA=1) {
# A fast and memory-saving version of A%*%x
# For Moler matrix. Note we need a matrix argument to match other functions
n <- length(x)
j <- 1:n
ax <- rep(0, n)
for (i in 1:n) {
term <- x * (pmin(i, j) - 2)
ax[i] <- sum(term[-i])
}
ax <- ax + j*x
ax
}
dyn.load("moler.so")
cat("Is the mat multiply loaded? ",is.loaded("moler"),"\n")
axftn<-function(x, AA=1) { # ignore second argument
n<-length(x) # could speed up by having this passed
vout<-rep(0,n) # purely for storage
res<-(.Fortran("moler", n=as.integer(n), x=as.double(x), vout=as.double(vout)))$vout
}
dyn.load("moler.so")
cat("Is the mat multiply loaded? ",is.loaded("moler"),"\n")
require(microbenchmark)
nmax<-10
ptable<-matrix(NA, nrow=nmax, ncol=11) # to hold results
# loop over sizes
for (ni in 1:nmax){
n<-50*ni
x<-runif(n) # generate a vector
ptable[[ni, 1]]<-n
AA<-molermat(n)
tax<- microbenchmark(oax<-ax(x, AA), times=mbt)$time
taxx<-microbenchmark(oaxx<-axx(x, AA), times=mbt)$time
if (! identical(oax, oaxx)) stop("oaxx NOT correct")
taxftn<-microbenchmark(oaxftn<-axftn(x, AA=1), times=mbt)$time
if (! identical(oax, oaxftn)) stop("oaxftn NOT correct")
taximp<-microbenchmark(oaximp<-aximp(x, AA=1), times=mbt)$time
if (! identical(oax, oaximp)) stop("oaximp NOT correct")
taxmfi<-microbenchmark(oaxmfi<-axmolerfast(x, AA=1), times=mbt)$time
if (! identical(oax, oaxmfi)) stop("oaxmfi NOT correct")
ptable[[ni, 2]]<-msect(tax); ptable[[ni,3]]<-msecr(tax)
ptable[[ni, 4]]<-msect(taxx); ptable[[ni, 5]]<-msecr(taxx)
ptable[[ni, 6]]<-msect(taxftn); ptable[[ni, 7]]<-msecr(taxftn)
ptable[[ni, 8]]<-msect(taximp); ptable[[ni,9]]<-msecr(taximp)
ptable[[ni, 10]]<-msect(taxmfi); ptable[[ni,11]]<-msecr(taxmfi)
}
axtym<-data.frame(n=ptable[,1], ax=ptable[,2], sd_ax=ptable[,3],  axx=ptable[,4],
sd_axx=ptable[,5],  axftn=ptable[,6], sd_axftn=ptable[,7],
aximp=ptable[,8], sd_aximp=ptable[,9],
axmfast=ptable[,10], sd_axmfast=ptable[,11])
print(axtym)
# explain table
expln <- c("ax = R matrix * vector  A %*% x",
"axx = R crossprod A, x",
"axftn = Fortran version of implicit Moler A * x",
"aximp = implicit moler A*x in R",
"axmfast = A fast and memory-saving version of A %*% x",
"Times in milliseconds from microbenchmark")
for (exx in expln) { cat(exx,"\n")}
cat("Times (in millisecs) adjusted for matrix build\n")
adjtym<-data.frame(n=axtym$n, axbld=axtym$ax+bmattym$buildi,
axxbld=axtym$axx+bmattym$buildi,
axftn=axtym$axftn, aximp=axtym$aximp)
print(adjtym)
dyn.load("moler.so")
n<-500
x<-runif(n) # generate a vector
AA<-molermat(n)
tdi<-microbenchmark(rdi<-rqdir(x, AA))$time
cat("Direct algorithm: ",msect(tdi),"sd=",msecr(tdi),"\n")
t1i<-microbenchmark(r1i<-ray1(x, AA))$time
cat("ray1: mat-mult algorithm: ",msect(t1i),"sd=",msecr(t1i),"\n")
t2i<-microbenchmark(r2i<-ray2(x, AA))$time
cat("ray2: crossprod algorithm: ",msect(t2i),"sd=",msecr(t2i),"\n")
t3fi<-microbenchmark(r3i<-ray3(x, AA, ax=axftn))$time
cat("ray3: ax Fortran + crossprod: ",mean(t3fi)*0.001,"\n")
t3ri<-microbenchmark(r3i<-ray3(x, AA, ax=axmolerfast))$time
cat("ray3: ax fast R implicit + crossprod: ",msect(t3ri),"sd=",msecr(t3ri),"\n")
cat("Test geradin with explicit matrix multiplication\n")
n<-10
AA<-molerfast(n)
BB=diag(rep(1,n))
x<-runif(n)
tg<-microbenchmark(ag<-geradin(x, ax, bx, AA=AA, BB=BB,
control=list(trace=FALSE)), times=mbt)
mbt<-25 # default to 5 repetitions in microbenchmark while sorting out text
msect<-function(times){
round(mean(times)*0.001,0)
}
msecr<-function(times){
#   round((max(times)-min(times))*0.001,0)
round(sd(times)*0.001,0)
}
molermat<-function(n){
A<-matrix(NA, nrow=n, ncol=n)
for (i in 1:n){
for (j in 1:n) {
if (i == j) A[i,i]<-i
else A[i,j]<-min(i,j) - 2
}
}
A
}
molerfast <- function(n) {
# A fast version of `molermat'
A <- matrix(0, nrow = n, ncol = n)
j <- 1:n
for (i in 1:n) {
A[i, 1:i] <- pmin(i, 1:i) - 2
}
A <- A + t(A)
diag(A) <- 1:n
A
}
require(microbenchmark)
nmax<-10
mtable<-matrix(NA, nrow=nmax, ncol=5) # to hold results
rtable<-mtable
# loop over sizes
for (ni in 1:nmax){
n<-50*ni
mtable[[ni, 1]]<-n
rtable[[ni, 1]]<-n
# Note "unit" argument is ONLY for display. time is in nanoseconds
ti<-microbenchmark(ai<-molermat(n), unit="us", times=mbt)$time
tfi<-microbenchmark(afi<-molerfast(n), unit="us", times=mbt)$time
if (! identical(ai, afi)) stop("Different outcomes == molermat, molerfast")
osize<-object.size(ai)
tevs<-microbenchmark(evs<-eigen(ai), unit="us", times=mbt)$time
mtable[[ni,2]]<-msect(ti)
mtable[[ni,3]]<-osize
mtable[[ni,4]]<-msect(tevs)
mtable[[ni,5]]<-msect(tfi)
rtable[[ni,2]]<-msecr(ti)
rtable[[ni,3]]<-osize
rtable[[ni,4]]<-msecr(tevs)
rtable[[ni,5]]<-msecr(tfi)
}
bmattym<-data.frame(n=mtable[,1], osize=mtable[,3], buildi=mtable[,2],
buildir=rtable[,2], eigentime=mtable[,4], eigentimr=rtable[,4],
bfast=mtable[,5], bfastr=rtable[,5])
print(bmattym)
cat("osize - matrix size in bytes\n")
cat("eigentime - all eigensolutions time\n")
cat("buildi - interpreted build time, range\n")
cat("bfast - interpreted vectorized build time\n")
cat("Times converted to milliseconds\n")
ti<-as.vector(mtable[,2])
tf<-as.vector(mtable[,5])
os<-as.vector(mtable[,3])
n<-as.vector(mtable[,1])
plot(n, ti)
xx<-1:max(mtable[,1])
n2<-n*n
itime<-lm(ti~n+n2)
summary(itime)
ftime<-lm(tf~n+n2)
summary(ftime)
iti<-coef(itime)
yy<-iti[1]+iti[2]*xx+iti[3]*xx*xx
points(xx,yy, type='l')
fti<-coef(ftime)
ww<-fti[1]+fti[2]*xx+fti[3]*xx*xx
points(n, tf, col='red')
points(xx, ww, type='l', col='red')
title(main="Execution time vs matrix size")
title(sub="molermat (black) and molerfast (red) matrix builds")
osize<-lm(os~n+n2)
summary(osize)
cos<-coef(osize)
zz<-cos[1]+cos[2]*xx+cos[3]*xx*xx
plot(n, os)
points(xx, zz, type='l')
title(main="Execution time vs matrix size")
title(sub="eigen() on Moler matrix")
rqdir<-function(x, AA){
rq<-0.0
n<-length(x) # assume x, AA conformable
for (i in 1:n) {
for (j in 1:n) {
rq<-rq+x[i]*AA[[i,j]]*x[j]
}
}
rq
}
ray1<-function(x, AA){
rq<-  t(x)%*%AA%*%x
}
ray2<-function(x, AA){
rq<-  as.numeric(crossprod(x, crossprod(AA,x)))
}
ray3<-function(x, AA, ax=axftn){
# ax is a function to form AA%*%x
rq<- - as.numeric(crossprod(x, ax(x, AA)))
}
ax<-function(x, AA){
u<- as.numeric(AA%*%x)
}
axx<-function(x, AA){
u<- as.numeric(crossprod(AA, x))
}
aximp<-function(x, AA=1){ # implicit moler A*x
n<-length(x)
y<-rep(0,n)
for (i in 1:n){
tt<-0.
for (j in 1:n) {
if (i == j) tt<-tt+i*x[i]
else tt<-tt+(min(i,j) - 2)*x[j]
}
y[i]<-tt
}
y
}
ident<-function(x, B=1) x # identity
axmolerfast <- function(x, AA=1) {
# A fast and memory-saving version of A%*%x
# For Moler matrix. Note we need a matrix argument to match other functions
n <- length(x)
j <- 1:n
ax <- rep(0, n)
for (i in 1:n) {
term <- x * (pmin(i, j) - 2)
ax[i] <- sum(term[-i])
}
ax <- ax + j*x
ax
}
dyn.load("moler.so")
cat("Is the mat multiply loaded? ",is.loaded("moler"),"\n")
axftn<-function(x, AA=1) { # ignore second argument
n<-length(x) # could speed up by having this passed
vout<-rep(0,n) # purely for storage
res<-(.Fortran("moler", n=as.integer(n), x=as.double(x), vout=as.double(vout)))$vout
}
dyn.load("moler.so")
cat("Is the mat multiply loaded? ",is.loaded("moler"),"\n")
require(microbenchmark)
nmax<-10
ptable<-matrix(NA, nrow=nmax, ncol=11) # to hold results
# loop over sizes
for (ni in 1:nmax){
n<-50*ni
x<-runif(n) # generate a vector
ptable[[ni, 1]]<-n
AA<-molermat(n)
tax<- microbenchmark(oax<-ax(x, AA), times=mbt)$time
taxx<-microbenchmark(oaxx<-axx(x, AA), times=mbt)$time
if (! identical(oax, oaxx)) stop("oaxx NOT correct")
taxftn<-microbenchmark(oaxftn<-axftn(x, AA=1), times=mbt)$time
if (! identical(oax, oaxftn)) stop("oaxftn NOT correct")
taximp<-microbenchmark(oaximp<-aximp(x, AA=1), times=mbt)$time
if (! identical(oax, oaximp)) stop("oaximp NOT correct")
taxmfi<-microbenchmark(oaxmfi<-axmolerfast(x, AA=1), times=mbt)$time
if (! identical(oax, oaxmfi)) stop("oaxmfi NOT correct")
ptable[[ni, 2]]<-msect(tax); ptable[[ni,3]]<-msecr(tax)
ptable[[ni, 4]]<-msect(taxx); ptable[[ni, 5]]<-msecr(taxx)
ptable[[ni, 6]]<-msect(taxftn); ptable[[ni, 7]]<-msecr(taxftn)
ptable[[ni, 8]]<-msect(taximp); ptable[[ni,9]]<-msecr(taximp)
ptable[[ni, 10]]<-msect(taxmfi); ptable[[ni,11]]<-msecr(taxmfi)
}
axtym<-data.frame(n=ptable[,1], ax=ptable[,2], sd_ax=ptable[,3],  axx=ptable[,4],
sd_axx=ptable[,5],  axftn=ptable[,6], sd_axftn=ptable[,7],
aximp=ptable[,8], sd_aximp=ptable[,9],
axmfast=ptable[,10], sd_axmfast=ptable[,11])
print(axtym)
# explain table
expln <- c("ax = R matrix * vector  A %*% x",
"axx = R crossprod A, x",
"axftn = Fortran version of implicit Moler A * x",
"aximp = implicit moler A*x in R",
"axmfast = A fast and memory-saving version of A %*% x",
"Times in milliseconds from microbenchmark")
for (exx in expln) { cat(exx,"\n")}
cat("Times (in millisecs) adjusted for matrix build\n")
adjtym<-data.frame(n=axtym$n, axbld=axtym$ax+bmattym$buildi,
axxbld=axtym$axx+bmattym$buildi,
axftn=axtym$axftn, aximp=axtym$aximp)
print(adjtym)
dyn.load("moler.so")
n<-500
x<-runif(n) # generate a vector
AA<-molermat(n)
tdi<-microbenchmark(rdi<-rqdir(x, AA))$time
cat("Direct algorithm: ",msect(tdi),"sd=",msecr(tdi),"\n")
t1i<-microbenchmark(r1i<-ray1(x, AA))$time
cat("ray1: mat-mult algorithm: ",msect(t1i),"sd=",msecr(t1i),"\n")
t2i<-microbenchmark(r2i<-ray2(x, AA))$time
cat("ray2: crossprod algorithm: ",msect(t2i),"sd=",msecr(t2i),"\n")
t3fi<-microbenchmark(r3i<-ray3(x, AA, ax=axftn))$time
cat("ray3: ax Fortran + crossprod: ",mean(t3fi)*0.001,"\n")
t3ri<-microbenchmark(r3i<-ray3(x, AA, ax=axmolerfast))$time
cat("ray3: ax fast R implicit + crossprod: ",msect(t3ri),"sd=",msecr(t3ri),"\n")
# spgRQ.R
molerfast <- function(n) {
# A fast version of `molermat'
A <- matrix(0, nrow = n, ncol = n)
j <- 1:n
for (i in 1:n) {
A[i, 1:i] <- pmin(i, 1:i) - 2
}
A <- A + t(A)
diag(A) <- 1:n
A
}
rqfast<-function(x){
rq<-as.numeric(t(x) %*% axmolerfast(x))
rq
}
rqneg<-function(x) { -rqfast(x)}
proj <- function(x) {sign(x[1]) * x/sqrt(c(crossprod(x))) } # from ravi
# Note that the c() is needed in denominator to avoid error msgs
require(BB)
n<-100
x<-rep(1,n)
x<-x/as.numeric(sqrt(crossprod(x)))
AA<-molerfast(n)
teig<-microbenchmark(evs<-eigen(AA), times=mbt)$time
cat("eigen time =", msect(teig),"sd=",msecr(teig),"\n")
tmin<-microbenchmark(amin<-spg(x, fn=rqfast, project=proj,
control=list(trace=FALSE)), times=mbt)$time
molerfast <- function(n) {
# A fast version of `molermat'
A <- matrix(0, nrow = n, ncol = n)
j <- 1:n
for (i in 1:n) {
A[i, 1:i] <- pmin(i, 1:i) - 2
}
A <- A + t(A)
diag(A) <- 1:n
A
}
system("gfortran ./a25moler.f")
system("gfortran ./a25moler.f")
cat("Geradin fortran version a25moler.f")
tmin100<-msect(microbenchmark(system("./a.out <n100min.txt > out100min.txt"), times=mbt)$time)
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
tbld100<-msect(microbenchmark(AA<-molerfast(100), times=mbt)$time)
teig100<-msect(microbenchmark(a100<-eigen(AA), times=mbt)$time)
tmin100
tmax100
tbld100
teig100
cat("eigen(): n=100 build time=",tbld100,"  eigen time=",teig100,"\n")
vecmin<-a100$vectors[,100]
vecmax<-a100$vectors[,1]
cat("Minimal Eigenvalue =",a100$values[100],"  RQ=", ray1(vecmin, AA))
cat("Maximal Eigenvalue =",a100$values[1],"  RQ=", ray1(vecmax, AA))
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
cat("Geradin fortran version a25moler.f")
tmin100<-msect(microbenchmark(system("./a.out <n100min.txt > out100min.txt"), times=mbt)$time)
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
tbld100<-msect(microbenchmark(AA<-molerfast(100), times=mbt)$time)
teig100<-msect(microbenchmark(a100<-eigen(AA), times=mbt)$time)
tmin100
tmax100
tbld100
teig100
cat("eigen(): n=100 build time=",tbld100,"  eigen time=",teig100,"\n")
vecmin<-a100$vectors[,100]
vecmax<-a100$vectors[,1]
cat("Minimal Eigenvalue =",a100$values[100],"  RQ=", ray1(vecmin, AA))
cat("Maximal Eigenvalue =",a100$values[1],"  RQ=", ray1(vecmax, AA))
cat("Geradin fortran version a25moler.f")
tmin100<-msect(microbenchmark(system("./a.out <n100min.txt > out100min.txt"), times=mbt)$time)
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
tbld100<-msect(microbenchmark(AA<-molerfast(100), times=mbt)$time)
teig100<-msect(microbenchmark(a100<-eigen(AA), times=mbt)$time)
tmin100
tmax100
tbld100
teig100
cat("eigen(): n=100 build time=",tbld100,"  eigen time=",teig100,"\n")
vecmin<-a100$vectors[,100]
vecmax<-a100$vectors[,1]
cat("Minimal Eigenvalue =",a100$values[100],"  RQ=", ray1(vecmin, AA))
cat("Maximal Eigenvalue =",a100$values[1],"  RQ=", ray1(vecmax, AA))
cat("Geradin fortran version a25moler.f")
tmin100<-msect(microbenchmark(system("./a.out <n100min.txt > out100min.txt"), times=mbt)$time)
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
tbld100<-msect(microbenchmark(AA<-molerfast(100), times=mbt)$time)
teig100<-msect(microbenchmark(a100<-eigen(AA), times=mbt)$time)
cat("eigen(): n=100 build time=",tbld100,"  eigen time=",teig100,"\n")
vecmin<-a100$vectors[,100]
vecmax<-a100$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a100$values[100],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin100,"\n")
system("cat out100min.txt")
cat("eigen: Maximal Eigenvalue =",a100$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin100,"\n")
system("cat out100max.txt")
cat("Geradin fortran version a25moler.f")
tmin100<-msect(microbenchmark(system("./a.out <n100min.txt > out100min.txt"), times=mbt)$time)
tmax100<-msect(microbenchmark(system("./a.out <n100max.txt > out100max.txt"), times=mbt)$time)
tbld100<-msect(microbenchmark(AA<-molerfast(100), times=mbt)$time)
teig100<-msect(microbenchmark(a100<-eigen(AA), times=mbt)$time)
cat("eigen(): n=100 build time=",tbld100,"  eigen time=",teig100,"\n")
vecmin<-a100$vectors[,100]
vecmax<-a100$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a100$values[100],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin100,"\n")
system("cat out100min.txt")
cat("eigen: Maximal Eigenvalue =",a100$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin100,"\n")
system("cat out100max.txt")
tmin200<-msect(microbenchmark(system("./a.out <n200min.txt > out200min.txt"), times=mbt)$time)
tmax200<-msect(microbenchmark(system("./a.out <n200max.txt > out200max.txt"), times=mbt)$time)
tbld200<-msect(microbenchmark(AA<-molerfast(200), times=mbt)$time)
teig200<-msect(microbenchmark(a200<-eigen(AA), times=mbt)$time)
cat("eigen(): n=200 build time=",tbld200,"  eigen time=",teig200,"\n")
vecmin<-a200$vectors[,200]
vecmax<-a200$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a200$values[200],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin200,"\n")
system("cat out200min.txt")
cat("eigen: Maximal Eigenvalue =",a200$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin200,"\n")
system("cat out200max.txt")
tmin300<-msect(microbenchmark(system("./a.out <n300min.txt > out300min.txt"), times=mbt)$time)
tmax300<-msect(microbenchmark(system("./a.out <n300max.txt > out300max.txt"), times=mbt)$time)
tbld300<-msect(microbenchmark(AA<-molerfast(300), times=mbt)$time)
teig300<-msect(microbenchmark(a300<-eigen(AA), times=mbt)$time)
cat("eigen(): n=300 build time=",tbld300,"  eigen time=",teig300,"\n")
vecmin<-a300$vectors[,300]
vecmax<-a300$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a300$values[300],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin300,"\n")
system("cat out300min.txt")
cat("eigen: Maximal Eigenvalue =",a300$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin300,"\n")
system("cat out300max.txt")
tmin400<-msect(microbenchmark(system("./a.out <n400min.txt > out400min.txt"), times=mbt)$time)
tmax400<-msect(microbenchmark(system("./a.out <n400max.txt > out400max.txt"), times=mbt)$time)
tbld400<-msect(microbenchmark(AA<-molerfast(400), times=mbt)$time)
teig400<-msect(microbenchmark(a400<-eigen(AA), times=mbt)$time)
cat("eigen(): n=400 build time=",tbld400,"  eigen time=",teig400,"\n")
vecmin<-a400$vectors[,400]
vecmax<-a400$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a400$values[400],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin400,"\n")
system("cat out400min.txt")
cat("eigen: Maximal Eigenvalue =",a400$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin400,"\n")
system("cat out400max.txt")
tmin500<-msect(microbenchmark(system("./a.out <n500min.txt > out500min.txt"), times=mbt)$time)
tmax500<-msect(microbenchmark(system("./a.out <n500max.txt > out500max.txt"), times=mbt)$time)
tbld500<-msect(microbenchmark(AA<-molerfast(500), times=mbt)$time)
teig500<-msect(microbenchmark(a500<-eigen(AA), times=mbt)$time)
cat("eigen(): n=500 build time=",tbld500,"  eigen time=",teig500,"\n")
vecmin<-a500$vectors[,500]
vecmax<-a500$vectors[,1]
cat("eigen: Minimal Eigenvalue =",a500$values[500],"  RQ=", ray1(vecmin, AA),"\n")
cat("Geradin-fortran - minimal eigenvalue time=",tmin500,"\n")
system("cat out500min.txt")
cat("eigen: Maximal Eigenvalue =",a500$values[1],"  RQ=", ray1(vecmax, AA),"\n")
cat("Geradin-fortran - maximal eigenvalue time=",tmin500,"\n")
system("cat out500max.txt")
